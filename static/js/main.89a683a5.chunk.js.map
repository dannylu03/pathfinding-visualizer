{"version":3,"sources":["components/Pathfinding/Node/Node.js","components/UI/Button.js","components/UI/Dropdown.js","components/UI/Navbar.js","components/Algorithms/PathfindingAlgorithms/astar.js","components/Algorithms/PathfindingAlgorithms/breadthFirstSearch.js","components/Algorithms/PathfindingAlgorithms/depthFirstSearch.js","components/Algorithms/PathfindingAlgorithms/dijkstras.js","components/Pathfinding/Pathfinding-Visualizer.js","components/UI/Modal.js","App.js","index.js"],"names":["Node","isStart","isFinish","row","col","isWall","onMouseEnter","onMouseDown","onMouseUp","isVisited","isShortest","classes","className","id","Button","props","onClick","clickHandler","text","Dropdown","useState","click","event","algorithmHandler","target","innerText","title","cName","map","item","index","Navbar","setClick","dropdown","setDropdown","algorithm","setAlgorithm","window","innerWidth","onMouseLeave","selectedAlgorithm","astarHandler","bfsHandler","dfsHandler","dijkstrasHandler","clearGridHandler","getUnvisitedNeighbors","node","grid","neighbors","x","y","push","length","filter","neighbor","neighborNotInUnvisitedNodes","unvisitedNodes","manhattenDistance","endNode","Math","abs","astar","startNode","visitedNodesInOrder","distance","sort","a","b","totalDistance","closestNode","shift","console","log","unshift","previousNode","breadthFirstSearch","unvisitedNeighbors","unvisitedNeighbor","depthFirstSearch","dijkstras","Infinity","numCols","numRows","NODE_END_ROW","NODE_END_COL","PathfindingVisualizer","setGrid","mousePressed","setMousePressed","getNewGridWithWalls","newGrid","slice","newNode","useEffect","initializeGrid","Array","i","createPoint","addNeighbors","Point","addneighbors","this","f","g","h","gridWithNode","rowIdx","colIdx","mouseDownHandler","mouseEnterHandler","visualizeShortestPath","nodesInsShortestPathOrder","setTimeout","nodesInShortestPathOrder","updateNodesForRender","document","getElementById","visualizeAlgorithm","currentNode","getNodesInShortestPathOrderAstar","getNodesInShortestPathOrderBFS","getNodesInShortestPathOrderDFS","getNodesInShortestPathOrderDijkstra","Modal","forwardRef","ref","display","setDisplay","useImperativeHandle","close","ReactDOM","createPortal","children","App","modalRef","useRef","render","StrictMode"],"mappings":"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","file":"static/js/main.89a683a5.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Node.css\";\n\nconst Node = ({\n  isStart,\n  isFinish,\n  row,\n  col,\n  isWall,\n  onMouseEnter,\n  onMouseDown,\n  onMouseUp,\n  isVisited,\n  isShortest,\n}) => {\n  const classes = isStart\n    ? \"node-start\"\n    : isWall\n    ? \"iswall\"\n    : isFinish\n    ? \"node-finish\"\n    : isVisited\n    ? \"node node-visited\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : \"\";\n  return (\n    <div\n      className={`node ${classes}`}\n      id={`node-${row}-${col}`}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React from \"react\";\nimport \"./Button.css\";\n\nconst Button = (props) => {\n  return (\n    <button className=\"btn\" onClick={props.clickHandler}>\n      {props.text}\n    </button>\n  );\n};\n\nexport default Button;\n","import React, { useState } from \"react\";\nimport \"./Dropdown.css\";\n\nconst Dropdown = (props) => {\n  const menuItems = [\n    {\n      title: \"A*\",\n      cName: \"dropdown-link\",\n    },\n    {\n      title: \"Dijkstra\",\n      cName: \"dropdown-link\",\n    },\n    {\n      title: \"Breadth First Search\",\n      cName: \"dropdown-link\",\n    },\n    {\n      title: \"Depth First Search\",\n      cName: \"dropdown-link\",\n    },\n  ];\n\n  const [click, setClick] = useState(false);\n\n  const clickHandler = () => setClick(!click);\n\n  const algorithmHandler = (event) => {\n    props.algorithmHandler(event.target.innerText);\n  };\n\n  return (\n    <>\n      <ul\n        onClick={algorithmHandler}\n        className={click ? \"dropdown-menu clicked\" : \"dropdown-menu\"}\n      >\n        {menuItems.map((item, index) => {\n          return (\n            <li key={index}>\n              <div className={item.cName}>{item.title}</div>\n            </li>\n          );\n        })}\n      </ul>\n    </>\n  );\n};\n\nexport default Dropdown;\n","import React, { useState } from \"react\";\nimport Button from \"./Button\";\nimport \"./Navbar.css\";\nimport Dropdown from \"./Dropdown\";\n\nconst Navbar = (props) => {\n  const [click, setClick] = useState(false);\n  const [dropdown, setDropdown] = useState(false);\n  const [algorithm, setAlgorithm] = useState(\"Algorithm\");\n\n  const algorithmHandler = (selectedAlgorithm) => {\n    setAlgorithm(selectedAlgorithm);\n    props.algorithmHandler(selectedAlgorithm);\n  };\n\n  const clickHandler = () => {\n    setClick(!click);\n  };\n\n  const onMouseEnter = () => {\n    if (window.innerWidth < 960) {\n      setDropdown(false);\n    } else {\n      setDropdown(true);\n    }\n  };\n\n  const onMouseLeave = () => {\n    if (window.innerWidth < 960) {\n      setDropdown(false);\n    } else {\n      setDropdown(false);\n    }\n  };\n\n  const visualizeAlgorithm = () => {\n    if (algorithm === \"A*\") props.astarHandler();\n    if (algorithm === \"Breadth First Search\") props.bfsHandler();\n    if (algorithm === \"Depth First Search\") props.dfsHandler();\n    if (algorithm === \"Dijkstra\") props.dijkstrasHandler();\n  };\n\n  return (\n    <>\n      <nav className=\"navbar\">\n        <div className=\"navbar-logo\">Pathfinding Visualizer</div>\n        <div className=\"menu-icon\" onClick={clickHandler}>\n          <i className={click ? \"fas fa-times\" : \"fas fa-bars\"} />\n        </div>\n        <ul className={click ? \"nav-menu active\" : \"nav-menu\"}>\n          <li\n            className=\"nav-item\"\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n          >\n            <div className=\"nav-links\">\n              {algorithm} <i className=\"fas fa-caret-down\" />\n            </div>\n\n            {dropdown && <Dropdown algorithmHandler={algorithmHandler} />}\n          </li>\n\n          <li className=\"nav-item\">\n            <div className=\"nav-links\">\n              <Button\n                clickHandler={visualizeAlgorithm}\n                text={`Visualize ${algorithm}`}\n              />\n            </div>\n          </li>\n\n          <li className=\"nav-item\">\n            <div className=\"nav-links\">Generate Maze</div>\n          </li>\n\n          <li className=\"nav-item\">\n            <div className=\"nav-links\">\n              <Button\n                clickHandler={props.clearGridHandler}\n                text={\"Clear Grid\"}\n              />\n            </div>\n          </li>\n        </ul>\n      </nav>\n    </>\n  );\n};\n\nexport default Navbar;\n","const astar = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  let unvisitedNodes = []; // Open list\n  let visitedNodesInOrder = []; // Closed list\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  // While there are still nodes to visit\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n\n    // Gets the first unvisited node\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    console.log(closestNode);\n    let neighbors = getUnvisitedNeighbors(closestNode, grid);\n\n    for (let neighbor of neighbors) {\n      let distance = closestNode.distance + 1;\n\n      if (neighborNotInUnvisitedNodes(neighbor, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbor);\n        neighbor.distance = distance;\n        neighbor.totalDistance =\n          distance + manhattenDistance(neighbor, endNode);\n        neighbor.previousNode = closestNode;\n      } else if (distance < neighbor.distance) {\n        neighbor.distance = distance;\n        neighbor.totalDistance =\n          distance + manhattenDistance(neighbor, endNode);\n        neighbor.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  let neighbors = [];\n  let { x, y } = node;\n\n  if (x !== 0) neighbors.push(grid[x - 1][y]);\n  if (y !== grid[0].length - 1) neighbors.push(grid[x][y + 1]);\n  if (x !== grid.length - 1) neighbors.push(grid[x + 1][y]);\n  if (y !== 0) neighbors.push(grid[x][y - 1]);\n\n  return neighbors.filter(\n    (neighbor) => !neighbor.isWall && !neighbor.isVisited\n  );\n};\n\nconst neighborNotInUnvisitedNodes = (neighbor, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.x === neighbor.x && node.y === neighbor.y) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst manhattenDistance = (node, endNode) => {\n  return Math.abs(node.x - endNode.x) + Math.abs(node.y - endNode.y);\n};\n\nexport const getNodesInShortestPathOrderAstar = (endNode) => {\n  let nodesInsShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    // End node -> endnode.previousNode -> endnode.previousNode.previousNode\n    // Continue this loop until no more nodes\n    nodesInsShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInsShortestPathOrder;\n};\n\nexport default astar;\n\n// const astar = (startNode, endNode) => {\n//   let openSet = []; // Nodes have to visit\n//   let closedSet = []; // Nodes already visited\n//   let path = [];\n//   let visitedNodes = [];\n\n//   openSet.push(startNode);\n\n//   // While there are still nodes that need to be visited\n//   while (openSet.length > 0) {\n//     let leastIndex = 0;\n//     for (let i = 0; i < openSet.length; i++) {\n//       if (openSet[i].f < openSet[leastIndex].f) {\n//         // Will get the node with the lowest f value\n//         leastIndex = i;\n//       }\n//     }\n\n//     let currentNode = openSet[leastIndex];\n//     visitedNodes.push(currentNode);\n\n//     if (currentNode === endNode) {\n//       let temp = currentNode;\n//       path.push(temp);\n//       while (temp.previousNode) {\n//         path.push(temp.previousNode);\n//         temp = temp.previousNode;\n//       }\n\n//       return { path, visitedNodes };\n//     }\n\n//     // If current node isn't end node, remove it from openSet and push to closed set\n//     openSet = openSet.filter((elt) => elt !== currentNode);\n//     closedSet.push(currentNode);\n\n//     let neighbors = currentNode.neighbors;\n//     for (let i = 0; i < neighbors.length; i++) {\n//       let neighbor = neighbors[i];\n//       if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n//         let tempG = currentNode.g + 1;\n//         let newPath = false;\n\n//         if (openSet.includes(neighbor)) {\n//           if (tempG < neighbor.g) {\n//             neighbor.g = tempG;\n//             newPath = true;\n//           }\n//         } else {\n//           neighbor.g = tempG;\n//           newPath = true;\n//           openSet.push(neighbor);\n//         }\n\n//         if (newPath) {\n//           neighbor.h = heruistic(neighbor, endNode);\n//           neighbor.f = neighbor.g + neighbor.h;\n//           neighbor.previousNode = currentNode;\n//         }\n//       }\n//     }\n//   }\n//   return { path, visitedNodes, error: \"No path found\" };\n// };\n\n// const heruistic = (neighbor, endNode) => {\n//   let d = Math.abs(neighbor.x - neighbor.y) + Math.abs(endNode.x - endNode.y);\n//   return d;\n// };\n\n// export default astar;\n","const breadthFirstSearch = (grid, startNode, endNode) => {\n  let unvisitedNodes = []; // queue\n  let visitedNodesInOrder = [];\n\n  // Start node starts the queue\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n\n    if (closestNode.isWall) continue;\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    visitedNodesInOrder.push(closestNode);\n\n    closestNode.isVisited = true;\n    let unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (let unvisitedNeighbor of unvisitedNeighbors) {\n      unvisitedNeighbor.previousNode = closestNode;\n      if (neighborNotInUnvisitedNodes(unvisitedNeighbor, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbor); // Add to the queue\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  let neighbors = [];\n  let { x, y } = node;\n  if (x !== 0) neighbors.push(grid[x - 1][y]);\n  if (y !== grid[0].length - 1) neighbors.push(grid[x][y + 1]);\n  if (x !== grid.length - 1) neighbors.push(grid[x + 1][y]);\n  if (y !== 0) neighbors.push(grid[x][y - 1]);\n\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst neighborNotInUnvisitedNodes = (neighbor, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.x === neighbor.x && node.y === neighbor.y) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const getNodesInShortestPathOrderBFS = (endNode) => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default breadthFirstSearch;\n","/* IMPLEMENTATION\n1. Add root node to stack\n2. Loop on the stack as long it's not empty\n  1. Get node at top of the stack (current), mark as visited and remove it\n  2. For every unvisited child of current node:\n    1. Check if it's the endNode, if so return the childNode\n    2. Otherwise, push it to the stack\n3. If stack is empty, then endNode was not found.\n*/\n\nconst depthFirstSearch = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  let unvisitedNodes = []; // Stack\n  let visitedNodesInOrder = [];\n\n  unvisitedNodes.push(startNode); // Add root node to stack\n\n  // Loop on stack as long as it's not empty\n  while (unvisitedNodes.length !== 0) {\n    // Removes startNode and assigns closestNode to it's value\n    let closestNode = unvisitedNodes.shift();\n\n    if (closestNode.isWall) continue;\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    // Mark as visited\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n\n    // Get unvisited child nodes (Neighbors)\n    let unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (let unvisitedNeighbor of unvisitedNeighbors) {\n      unvisitedNeighbor.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbor); // Push to stack\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  let neighbors = [];\n  let { x, y } = node;\n  if (x !== 0) neighbors.push(grid[x - 1][y]);\n  if (y !== grid[0].length - 1) neighbors.push(grid[x][y + 1]);\n  if (x !== grid.length - 1) neighbors.push(grid[x + 1][y]);\n  if (y !== 0) neighbors.push(grid[x][y - 1]);\n\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nexport const getNodesInShortestPathOrderDFS = (endNode) => {\n  let nodesInsShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInsShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInsShortestPathOrder;\n};\n\nexport default depthFirstSearch;\n","const dijkstras = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  startNode.distance = 0; // Initial cost\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n\n  for (let row of grid) {\n    for (let node of row) {\n      unvisitedNodes.push(node);\n    }\n  }\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift(); // Removes first node in array and assigns value to closestNode\n\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    let unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (let unvisitedNeighbor of unvisitedNeighbors) {\n      unvisitedNeighbor.distance = closestNode.distance + 1;\n      unvisitedNeighbor.previousNode = closestNode;\n    }\n  }\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  let neighbors = [];\n  let { x, y } = node;\n\n  if (x !== 0) neighbors.push(grid[x - 1][y]);\n  if (y !== grid[0].length - 1) neighbors.push(grid[x][y + 1]);\n  if (x !== grid.length - 1) neighbors.push(grid[x + 1][y]);\n  if (y !== 0) neighbors.push(grid[x][y - 1]);\n\n  return neighbors.filter(\n    (neighbor) => !neighbor.isWall && !neighbor.isVisited\n  );\n};\n\nconst neighborNotInUnvisitedNodes = (neighbor, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.x === neighbor.x && node.y === neighbor.y) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const getNodesInShortestPathOrderDijkstra = (endNode) => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default dijkstras;\n","import React, { useState, useEffect, Fragment } from \"react\";\nimport Node from \"./Node/Node\";\nimport Navbar from \"../UI/Navbar\";\nimport \"./PathfindingVisualizer.css\";\nimport astar from \"../Algorithms/PathfindingAlgorithms/astar\";\nimport { getNodesInShortestPathOrderAstar } from \"../Algorithms/PathfindingAlgorithms/astar\";\nimport breadthFirstSearch from \"../Algorithms/PathfindingAlgorithms/breadthFirstSearch\";\nimport { getNodesInShortestPathOrderBFS } from \"../Algorithms/PathfindingAlgorithms/breadthFirstSearch\";\nimport depthFirstSearch from \"../Algorithms/PathfindingAlgorithms/depthFirstSearch\";\nimport { getNodesInShortestPathOrderDFS } from \"../Algorithms/PathfindingAlgorithms/depthFirstSearch\";\nimport dijkstras from \"../Algorithms/PathfindingAlgorithms/dijkstras\";\nimport { getNodesInShortestPathOrderDijkstra } from \"../Algorithms/PathfindingAlgorithms/dijkstras\";\n// Constants\n\nconst numCols = 35;\nconst numRows = 15;\n\nconst NODE_START_ROW = 4;\nconst NODE_START_COL = 4;\nconst NODE_END_ROW = numRows - 4;\nconst NODE_END_COL = numCols - 4;\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mousePressed, setMousePressed] = useState(false);\n  const [algorithm, setAlgorithm] = useState(\"\");\n\n  const getNewGridWithWalls = (grid, row, col) => {\n    let newGrid = grid.slice();\n    let node = grid[row][col];\n    let newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const algorithmHandler = (selectedAlgorithm) => {\n    setAlgorithm(selectedAlgorithm);\n  };\n\n  const mouseDownHandler = (row, col) => {\n    const newGrid = getNewGridWithWalls(grid, row, col);\n    setGrid(newGrid);\n    setMousePressed(true);\n  };\n\n  const mouseEnterHandler = (row, col) => {\n    if (mousePressed) {\n      const newGrid = getNewGridWithWalls(grid, row, col);\n      setGrid(newGrid);\n      setMousePressed(true);\n    }\n  };\n\n  const mouseUpHandler = () => {\n    setMousePressed(false);\n  };\n\n  useEffect(() => {\n    initializeGrid();\n  }, []);\n\n  const clearGrid = () => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        if (\n          !(\n            (row === NODE_START_ROW && col === NODE_START_COL) ||\n            (row === NODE_END_ROW && col === NODE_END_COL)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    initializeGrid();\n  };\n\n  // Creates the grid\n  const initializeGrid = () => {\n    let grid = new Array(numRows);\n\n    for (let i = 0; i < numRows; i++) {\n      grid[i] = new Array(numCols);\n    }\n\n    // Makes a node/point instance\n    createPoint(grid);\n    setGrid(grid);\n\n    // Add neighbors for all the nodes instances\n    addNeighbors(grid);\n\n    const startNode = grid[NODE_START_ROW][NODE_START_COL];\n    const endNode = grid[NODE_END_ROW][NODE_END_COL];\n\n    // Makes sure the start and end node have right styling\n    if (startNode.className !== \"node node-start\") {\n      startNode.className = \"node node-start\";\n    }\n\n    if (endNode.className !== \"node node-finish\") {\n      endNode.className = \"node node-finish\";\n    }\n\n    startNode.isWall = false; // Start node will never be a wall\n    endNode.isWall = false;\n  };\n\n  // Creates the nodes\n  const createPoint = (grid) => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        grid[row][col] = new Point(row, col);\n      }\n    }\n  };\n\n  // Loops through all nodes in the grid and neighbors to each of them\n  const addNeighbors = (grid) => {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        grid[row][col].addneighbors(grid);\n      }\n    }\n  };\n\n  // Class constructor for a point/node object\n  function Point(row, col) {\n    this.x = row; // Rows\n    this.y = col; // Cols\n    this.isStart = this.x === NODE_START_ROW && this.y === NODE_START_COL;\n    this.isFinish = this.x === NODE_END_ROW && this.y === NODE_END_COL;\n    this.f = 0; // the sum of g and h\n    this.g = 0; // Movement cost from start node to a given node\n    this.h = 0; // Estimated movement cost from given node and end node\n    this.neighbors = [];\n    this.previousNode = null;\n    this.isWall = false;\n    this.isVisited = false;\n    this.isShortest = false;\n    this.distance = Infinity;\n    this.totalDistance = Infinity;\n\n    // Adds neighbors to specific node instances\n    this.addneighbors = function (grid) {\n      // Checks for the boundaries of the grid, left, right, bottom, top\n      // Adds left node as a neighbor\n      if (this.x > 0) {\n        this.neighbors.push(grid[row - 1][col]);\n      }\n\n      // Adds right node as a neighbor\n      if (this.x < numRows - 1) {\n        this.neighbors.push(grid[row + 1][col]);\n      }\n\n      // Adds top node as a neigbor\n      if (this.y > 0) {\n        this.neighbors.push(grid[row][col - 1]);\n      }\n\n      // Adds bottom node as a neigbor\n      if (this.y < numCols - 1) {\n        this.neighbors.push(grid[row][col + 1]);\n      }\n    };\n  }\n\n  // Grid with Node\n  // Every row array contains arrays of column arrays created using point/node instances\n  const gridWithNode = (\n    <div>\n      {grid.map((row, rowIdx) => {\n        return (\n          <div key={rowIdx} className=\"row\">\n            {row.map((col, colIdx) => {\n              const { isStart, isFinish, isWall, isVisited, isShortest } = col;\n              return (\n                <Node\n                  key={colIdx}\n                  isStart={isStart}\n                  isFinish={isFinish}\n                  isVisited={isVisited}\n                  isShortest={isShortest}\n                  row={rowIdx}\n                  col={colIdx}\n                  isWall={isWall}\n                  onMouseDown={(row, col) => mouseDownHandler(row, col)}\n                  onMouseEnter={(row, col) => mouseEnterHandler(row, col)}\n                  onMouseUp={() => mouseUpHandler()}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n\n  const updateNodesForRender = (\n    grid,\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    let newGrid = grid.slice();\n    for (let node of visitedNodesInOrder) {\n      if (\n        (node.x === NODE_START_ROW && node.y === NODE_START_COL) ||\n        (node.x === NODE_END_ROW && node.y === NODE_END_COL)\n      )\n        continue;\n      let newNode = {\n        ...node,\n        isVisited: true,\n      };\n      newGrid[node.x][node.y] = newNode;\n    }\n    for (let node of nodesInShortestPathOrder) {\n      if (node.x === NODE_END_ROW && node.y === NODE_END_COL) {\n        return newGrid;\n      }\n      let newNode = {\n        ...node,\n        isVisited: false,\n        isShortest: true,\n      };\n      newGrid[node.x][node.y] = newNode;\n    }\n  };\n\n  const visualizeShortestPath = (\n    nodesInsShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    for (let i = 1; i < nodesInsShortestPathOrder.length - 1; i++) {\n      if (i === nodesInsShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInsShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n        }, i * 30);\n        return;\n      }\n      let node = nodesInsShortestPathOrder[i];\n      setTimeout(() => {\n        document.getElementById(`node-${node.x}-${node.y}`).className =\n          \"node node-shortest-path\";\n      }, i * 30);\n    }\n  };\n  const visualizeAlgorithm = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    let newGrid = grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.x][node.y] = newNode;\n      }\n    }\n    setGrid(grid);\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      // When we have visited all the nodes\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          visualizeShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * 10);\n        return;\n      }\n\n      // Otherwise mark the node as visited in css\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.x}-${node.y}`).className =\n          \"node node-visited\";\n      }, i * 10);\n    }\n  };\n\n  const visualizeAstar = () => {\n    setTimeout(() => {\n      const startNode = grid[NODE_START_ROW][NODE_START_COL];\n      const endNode = grid[NODE_END_ROW][NODE_END_COL];\n      const visitedNodesInOrder = astar(grid, startNode, endNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderAstar(endNode);\n\n      visualizeAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, 10);\n  };\n\n  const visualizeBFS = () => {\n    setTimeout(() => {\n      const startNode = grid[NODE_START_ROW][NODE_START_COL];\n      const endNode = grid[NODE_END_ROW][NODE_END_COL];\n      const visitedNodesInOrder = breadthFirstSearch(grid, startNode, endNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(endNode);\n      visualizeAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, 10);\n  };\n\n  const visualizeDFS = () => {\n    setTimeout(() => {\n      const startNode = grid[NODE_START_ROW][NODE_START_COL];\n      const endNode = grid[NODE_END_ROW][NODE_END_COL];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, endNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(endNode);\n      visualizeAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, 10);\n  };\n\n  const visualizeDijkstras = () => {\n    setTimeout(() => {\n      const startNode = grid[NODE_START_ROW][NODE_START_COL];\n      const endNode = grid[NODE_END_ROW][NODE_END_COL];\n      const visitedNodesInOrder = dijkstras(grid, startNode, endNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDijkstra(endNode);\n      visualizeAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, 10);\n  };\n\n  return (\n    <Fragment>\n      <Navbar\n        astarHandler={visualizeAstar}\n        bfsHandler={visualizeBFS}\n        dfsHandler={visualizeDFS}\n        dijkstrasHandler={visualizeDijkstras}\n        clearGridHandler={clearGrid}\n        algorithmHandler={algorithmHandler}\n      />\n      <div className=\"grid\">{gridWithNode}</div>\n    </Fragment>\n  );\n};\n\nexport default PathfindingVisualizer;\n","import React, { useState, forwardRef, useImperativeHandle } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./Modal.css\";\n\nconst Modal = forwardRef((props, ref) => {\n  const [display, setDisplay] = useState(true);\n\n  useImperativeHandle(props.ref, () => {\n    return {\n      close: () => close(),\n    };\n  });\n\n  const close = () => {\n    setDisplay(false);\n  };\n\n  if (display) {\n    return ReactDOM.createPortal(\n      <div className={\"modal-wrapper\"}>\n        <div onClick={close} className={\"modal-backdrop\"} />\n        <div className=\"modal-box\">{props.children}</div>\n      </div>,\n      document.getElementById(\"modal-root\")\n    );\n  }\n\n  return null;\n});\n\nexport default Modal;\n","import React, { useRef } from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./components/Pathfinding/Pathfinding-Visualizer\";\nimport Modal from \"./components/UI/Modal\";\n\nfunction App() {\n  const modalRef = useRef();\n\n  return (\n    <>\n      <Modal ref={modalRef}>\n        <h1>Tutorial</h1>\n        <p>\n          <br />\n          <span>\n            Select an algorithm from the dropdown and click visualize algorithm\n            to visualize the path.\n          </span>\n          <br />\n          <br />\n          <span>To add walls, click and hold left click then drag mouse. </span>\n        </p>\n      </Modal>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}